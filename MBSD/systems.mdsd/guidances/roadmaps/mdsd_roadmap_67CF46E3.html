<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Roadmap: MDSD Roadmap</title>
<meta name="uma.type" content="Roadmap">
<meta name="uma.name" content="mdsd_roadmap">
<meta name="uma.presentationName" content="MDSD Roadmap">
<meta name="element_type" content="other">
<meta name="filetype" content="description">
<meta name="role" content="none">
<link rel="StyleSheet" href="./../../../css/default.css" type="text/css">
<script src="./../../../scripts/ContentPageResource.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSubSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageToolbar.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/contentPage.js" type="text/javascript" language="JavaScript"></script><script type="text/javascript" language="JavaScript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="_QClEsAQLEdy-Y8QEckP_4g"></div>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="pageTitle" nowrap="true">Roadmap: MDSD Roadmap</td><td width="100%">
<div align="right" id="contentPageToolbar"></div>
</td><td width="100%" class="expandCollapseLink" align="right"><a name="mainIndex" href="./../../../index.htm"></a><script language="JavaScript" type="text/javascript" src="./../../../scripts/treebrowser.js"></script></td>
</tr>
</table>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td class="pageTitleSeparator"><img src="./../../../images/shim.gif" alt="" title="" height="1"></td>
</tr>
</table>
<div class="overview">
<table width="97%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="50"><img src="./../../../images/roadmap.gif" alt="" title=""></td><td>
<table class="overviewTable" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top"></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Main Description</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<td class="sectionTableSingleCell"><h2>
    What is Systems Engineering?
</h2>
<p>
    The answer to the above quesiton provided by the <a href="http://www.incose.org/practice/whatissystemseng.aspx" target="_blank">International Council on Systems Engineering (INCOSE)</a> follows below:
</p>
<p>
    Systems Engineering is an interdisciplinary approach and means to enable the realization of successful systems. It
    focuses on defining customer needs and required functionality early in the development cycle, documenting requirements,
    then proceeding with design synthesis and system validation while considering the complete problem:
</p>
<ul>
    <li>
        Operations&nbsp;
    </li>
    <li>
        Cost & Schedule
    </li>
    <li>
        Performance&nbsp;
    </li>
    <li>
        Training & Support
    </li>
    <li>
        Test&nbsp;&nbsp;
    </li>
    <li>
        Disposal
    </li>
    <li>
        Manufacturing
    </li>
</ul>
<p>
    Systems Engineering integrates all the disciplines and specialty groups into a team effort forming a structured
    development process that proceeds from concept to production to operation. Systems Engineering considers both the
    business and the technical needs of all customers with the goal of providing a quality product that meets the user
    needs.
</p>
<p>
    A <a href="http://www.incose.org/practice/fellowsconsensus.aspx" target="_blank">Consensus of the INCOSE Fellows</a>
    has been reached on the definition of a System and what Systems Engineering is.&nbsp;
</p>
<p>
    Model Driven Systems Engineering supports the INCOSE Consensus statement.
</p>
<h2>
    Model Driven System Development (MDSD)
</h2>
<p>
    Model driven systems development helps to manage the complexity of designing a system.&nbsp; Managing the appropriate
    level of detail for any particular level of the model is an important component of MDSD.&nbsp; Several techniques are
    used to do this.
</p>
<blockquote>
    <p>
        Best practices are used to:
    </p>
    <ul>
        <li>
            Decompose systems, not requirements
        </li>
        <li>
            Enable both separation and integration of concerns
        </li>
        <li>
            Systems and components collaborate; so should development teams
        </li>
        <li>
            Specifications flow up and down the architecture
        </li>
        <li>
            Base the life cycle on removing risk and adding value
        </li>
        <li>
            Development organization should reflect product architecture
        </li>
    </ul>
    <p>
        Systems are implemented by:
    </p>
    <ul>
        <li>
            Modeling the system with UML and Use Cases
        </li>
        <li>
            Creation of a common vision with Context Workshops
        </li>
        <li>
            Use of RSA tooling and a RUP based methodology
        </li>
        <li>
            Working Iteratively focusing upon early risk removal
        </li>
        <li>
            Adoption of a program organization that mirrors the intended system architecture
        </li>
        <li>
            Ensuring that the architecture and design can be implemented with a technology readiness assessment
        </li>
    </ul>
</blockquote>
<h3>
    Model levels and abstraction
</h3>
<p>
    Intuitively, we think in terms of abstraction.&nbsp; MDSD formalizes this idea of abstraction through the use of model
    levels and levels of decomposition within a system.
</p>
<p>
    In our everyday life, we intuitively use abstraction to help us manage complexity. When we drive a car for example, we
    typically abstract away all of the internal workings of the car and consider the car as largely a "black box" with a
    few main interfaces including the steering wheel, accelerator and brake. At this level, we hide the internal
    implementation of these capabilities and consider only their usage from the outside. This places the car in a context
    of its usage by the driver and passengers.
</p>
<p>
    Our local mechanic, on the other hand, considers quite a different abstraction perspective when we bring in the car for
    "making a funny noise." To the mechanic, the car appears as a set of components, with each replaceable component in the
    car considered a black box, where we consider the entire car to be a black box. The mechanic is most aware of the
    interactions between components including the engine, transmission, braking system, etc.
</p>
<p>
    In considering systems, abstraction and levels of decomposition allow us to consider large systems and subsystems, and
    their relationships without being overwhelmed by their detailed internal complexity.
</p>
<p>
    There are three important factors in considering a level of decomposition:
</p>
<p>
    The purpose and type of the level (context, analysis, design or implementation)<br />
     What elements are considered black boxes<br />
     The interactions exposed and emphasized
</p>
<h3>
    Model Levels
</h3>
<p>
    <strong>Purpose of a Model Level</strong>
</p>
<p>
    In developing a comprehensive system-of-systems model, whether it be for an aircraft, an enterprise IT development
    project or a new business unit, a major challenge is figuring out the right set of levels with which to express the
    model. In MDSD we identify four model levels, each with a different purpose:
</p>
<ul>
    <li>
        Context
    </li>
    <li>
        Analysis
    </li>
    <li>
        Design
    </li>
    <li>
        Implementation
    </li>
</ul>
<p>
    The <strong>Context Model Level</strong>, which include the top level or enterprise level of decomposition, allow the
    system to be seen in the context of its usage by actors and other outside systems. Often this level expresses the area
    over which the team has control, or one level above that. For example, if we are modeling a new kind of traffic light,
    we may want to start at the level of the citywide traffic system, so that we can place the traffic light in its
    context. Thus the citywide traffic system would be our enterprise, our level 0 and the beginning of our model. This
    would be part of the context model level. A complex system could have more than one level of decomposition in the
    context model level, but in practice there is generally only one.
</p>
<p>
    The <strong>Analysis Model Level</strong> elaborates the functionality, logical structure and the distribution of the
    system. In this level, we create logical elements, distribution elements, collections of system functionality, and
    model their interactions. A uniqueness of this approach is that these interactions do not exist in isolation, but are
    derived precisely from the high level usages of the system. The Analysis model level provides an abstraction above that
    of actual design-no one designs or builds from an analysis level. Taking the citywide traffic system example above, an
    analysis level might include system elements such as the traffic signaling, traffic detection, central control and
    override control, among others.
</p>
<p>
    In the analysis model level, the elements considered to be black boxes are logical and distribution elements, made up
    of some combination of hardware, software, people and information. They may be as small as a single automated
    capability, or as large as an army. We chose them to be elements in our architecture so that we can reason about their
    interactions and responsibilities. The number of levels created depends on the complexity of the system.&nbsp;
</p>
<p>
    The <strong>Design Model Level</strong> captures the interaction between "designable" elements. At this model level,
    elements are generally homogenous, that is, they may consist of hardware, software or people, but not a combination of
    these. Through the MDSD approach, we will assign responsibility for specific operations to these elements, and the
    designers will use this specification to create the element.
</p>
<p>
    How design proceeds depends on the type of element. Software elements can use UML and use case realization, an approach
    very similar to MDSD, but applied at the software design level, to create the technical design of the software. The
    design of an electronic component would more likely be expressed as a schematic diagram, while a "people" element might
    use organizational charts and skill lists.
</p>
<p>
    The <strong>Implementation Model Level</strong> expresses how elements expressed in the design model level will be
    created in the real world. For software, this would include the structure of code modules, executables, DLLs, etc.
    while for hardware it might include circuit pathways, board layouts and the like.
</p>
<p>
    In MDSD we are concerned primarily with the context and analysis model levels because our main purpose is to understand
    the system in its context, analyze the behavior of the entire system and arrange the work to be performed by the
    design-and-build teams. These design-and-build teams may use the Rational Unified Process for software, and other
    discipline-specific approaches for the hardware design, and people design.
</p>
<h4>
    Black Box and White Box Perspectives
</h4>
<p>
    Black and white box are terms that refer to a perspective taken when approaching a system or a part of a system. To
    take a black box perspective means that we ignore the inner workings of the system, and focus only the interactions
    with that system. Most people take such a perspective with respect to a television. They don't know or care about how
    the TV works or what components exist inside, only that they can interact with it via its inputs (remote control, power
    plug, etc.) and outputs (screen and speakers). To take a black box perspective is to pay attention only to inputs and
    outputs and hide or ignore all of the internals.
</p>
<p>
    The act of changing the channel on the TV would simply be described by showing that the viewer presses "+"and the TV
    changes the channel it is currently displaying. Notice that there can be no mention of the screen or the tuner, because
    these are internal system elements.
</p>
<p>
    A white box perspective on the other hand includes information about two additional aspects of the system. In addition
    to the inputs and outputs, a white box perspective describes:
</p>
<ul>
    <li>
        Internal processes and functionality, and
    </li>
    <li>
        Internal system elements
    </li>
</ul>
<p>
    Described as a white box sequence, changing the channel on the TV would specify how the viewer presses the "+" button
    on the remote control, how the remote control sends an infrared signal to the TV, how the TV control interface tells
    the tuner to re-tune to another channel, and how the display controller presents the image of the new channel when its
    tuned. Notice that doing a white box description doesn't mean the system is fully decomposed to its lowest-level
    elements. White box descriptions still contain abstractions which are treated as black boxes. The "TV control
    interface" occurs in a white box expansion at this level of decomposition, and thus is treated as a black box. At a
    lower level of decomposition it too could be described in terms of its constituent components.
</p>
<p>
    It's useful to note that black and white box are not inherent attributes of an element. That is, there are no "black
    box elements" or "white box elements." There are only black and white box perspectives and we use both throughout the
    MDSD modeling process.
</p>
<p>
    At any given level of decomposition, there is a set of logical system elements considered from a black box perspective.
    These elements are treated as black boxes at that level of decomposition. White box elements within them are only
    considered at the next level of decomposition.
</p>
<p>
    Thus, choosing what levels of decomposition to include in the model allows the modeler to choose what system elements
    to expose. Part of this decision, in turn, depends on who is to be the audience for the model at that level of
    decomposition. We've probably all seen the disadvantage of exposing too much detail in front of a higher level
    audience. System elements exposed at a given level of decomposition should be recognizable to the audience and in fact,
    should be named in terms familiar to them. If we are speaking, for example, to department heads and business function
    owners in a mortgage company, it would not be wise to include elements such as message handlers and database managers
    in the model at this level, whereas elements like loan origination, credit and title would be acceptable.
</p>
<h4>
    Levels of Decomposition and Interaction
</h4>
<p>
    The most essential facet of a level of decomposition is the interactions it exposes or hides. Since each element in a
    level of decomposition is considered from the black box perspective only, the only interactions shown are those between
    them and the systems actors. Interactions with sub-elements inside these elements are hidden. An entertaining example
    comes from a recent class exercise where a group modeled a commercial aircraft. At a particular level of decomposition,
    the aircraft appeared as an element, and was described as including the airframe, all the systems on board and the
    crew. Since all of this was included in the black box designated aircraft, the model could not speak of anything inside
    it at this level. In describing how passengers began their travel, the model spoke of the passenger being greeted by
    the aircraft, and being guided to their seats by the aircraft. While it sounded odd, this is the only way to describe
    this behavior. Since the crew were considered part of the aircraft, the crew greeting the passenger must be described
    as the aircraft greeting the passenger.&nbsp; And in fact, this is a valuable approach since the design decision of
    whether to have flight attendants greeting passengers, or an automated system scanning ticket stubs and greeting them
    has not been taken at this level of decomposition.
</p>
<p>
    At the same time, what is highlighted in a level of decomposition is the interaction between the elements identified
    there. In the example above, it is the interaction between the passenger and the aircraft that is described. Which
    interactions are important to describe will be a major factor in deciding what levels of decomposition to use. Take the
    case of the pilot in our commercial aircraft. Is the pilot part of the system of the aircraft or outside the system?
    Each is a completely valid way of modeling the system, but which we choose depends on which interactions are important.
    If what's important is how the pilot interacts with the aircraft, treating the aircraft as a black box, using some kind
    of interface to the entire aircraft, then this would support making the pilot a separate entity at the level of the
    aircraft. This would allow us to describe the interaction between the pilot and the aircraft-as-a-black-box.
</p>
<p>
    If, on the other hand, it makes more sense to think of the pilot and the aircraft together as a system element, thus
    emphasizing, say, the control tower's interaction with the aircraft-including-pilot element, then this is the way to
    go. In fact, for several reasons, this is probably the better approach. If we are designing aircraft, then we are
    probably more interested in how the aircraft as a whole, interacts with elements outside it such as the control tower,
    passengers and gate crew.
</p>
<p>
    It probably makes more sense to think of the pilot as interacting with the elements or subsystems within the aircraft,
    not with the aircraft as a whole. Thus we would put the pilot as a separate element at a lower level of decomposition
    where the aircraft itself appears as a number of separate elements along with the pilot.
</p>
<p>
    In practice, this judgment about what to set as elements in your architecture comes mainly from experience in the
    domain. Choosing these elements is a key part of designing the system architecture.
</p>
<h3>
    Integration with RUP
</h3>
<p>
    MDSD has not beeen added as a separate RUP discipline, to underscore the unified nature of the teams, and the unified
    nature of the process.
</p>
<p>
    RUP without the&nbsp;MDSD plug-in is a process for software engineering, RUP <i>with</i> the MDSD plug-in is a systems
    engineering process for which software engineering (the RUP)&nbsp;then becomes a subset. The default RUP disciplines,
    business modeling, requirements, analysis and design, implementation, test, deployment, and the supporting disciplines,
    configuration and change management, project management and environment, are as much part of the fabric of systems
    engineering as software engineering. MDSD adds new tasks, artifacts and&nbsp;activities and modifies some existing ones
    to provide support for the wider scope of life cycle development and the additional concerns of systems engineering.
</p>
<p>
    Systems Engineering is not obviously delineated as a separate discipline&nbsp;in the Web site.&nbsp; MDSD inclusive of
    the existing RUP disciplines is, however, a Systems Engineering life cycle&nbsp;process.
</p>
<p>
    It is also important to understand the way the&nbsp;MDSD plug-in is articulated with respect to the rest of RUP: MDSD
    expects that systems are composed of subsystems, which in turn might be composed of subsystems, and so on.&nbsp;
    Systems, within the context of MDSD,&nbsp;are defined as and dealt with as Systems of Systems.
</p>
<p>
    The RUP with the&nbsp;MDSD extension is applicable at any level in the Systems of Systems hierarchy, including the
    lowest level, at which, at least for software, the behavior of a subsystem is realized by collaborations of software
    objects (and links). Also, a subsystem development, viewed from the level of its developers, is like the total system
    development in its process needs, that is, it needs to have an inception phase, elaboration phase, and so on. So, if
    you look at the overall system development plan, you find the RUP sequence of phases, then looking "inside," you find a
    number of RUP evolutions or lifecycles --&nbsp;one for each subsystem.&nbsp;
</p>
<p class="picturetext" align="left">
    Top-level activities are simply rolled-up from the lower levels. There are requirements, design, and other activities
    at each level, and separate logical plans. This permits one to <i>describe</i> the process simply, but still be able to
    construct plans of arbitrary complexity by recursive application of the RUP lifecycle. At any level, you then choose
    the activities, tasks, and steps within the tasks, appropriate to your purpose. As an example, consider the <a class="elementLinkWithType" href="./../../../systems.mdsd/capabilitypatterns/se_analysis_design_discipline_333E26A9.html" guid="_9MQf0VVmEdq-S-2DETo4XA">Capability Pattern: Analysis & Design - Systems Engineering</a>&nbsp;(workflow
    diagram): a late elaboration iteration for a systems development (at, for instance, Level 1 as shown above) appears to
    consist only of the <a class="elementLinkWithType" href="./../../../systems.mdsd/capabilitypatterns/refine_system_architecture_ED478575.html" guid="_1ln6EFVwEdqgIdhbAiG50A">Activity: Refine System Architecture</a> and <a class="elementLinkWithType" href="./../../../systems.mdsd/capabilitypatterns/analyze_system_behavior_38A5919C.html" guid="_5tCbYFVwEdqgIdhbAiG50A">Activity: Analyze System Behavior</a> (looking at the right-hand side of the workflow
    diagram). This is correct at the level it describes (Level 1 in this example) - there might be lower-level work taking
    place (in a concurrent RUP lifecycle) that contributes to this iteration - and in the example depicted above, there is
    lower-level work, at Level 2 on the Launch Segment, for example, and then Level 3 on the Launch Vehicle, and so on.
    These concepts, and the relationship of the artifacts produced at one level to levels above and below, are illustrated
    in <a class="elementLink" href="./../../../systems.mdsd/deliveryprocesses/mdsd_dp_BCE136E3.html" guid="_iwnH4Q7REdygjsWLoA98yA">Systems Engineering Delivery Process</a>.
</p>
<h2>
    Capability Maturity Model Integration (CMMI)
</h2>
<p>
    CMMI-DEV, V1.2,is the latest iteration of the CMMI process model.&nbsp; It integrates bodies of knowledge such as
    software engineering, systems engineering, hardware and design engineering, the engineering "-ilities," and
    acquisition.&nbsp; These bodies of knowledge, that were addressed separately in the past, are now integrated into the
    CMMI<sup>&reg;</sup> for Development, Version 1.2, process model.
</p>
<p>
    The prior designations of CMMI for systems engineering and software engineering (CMMI-SE/SW) were superseded by the
    title "CMMI for Development" to truly reflect the comprehensive integration of the bodies of knowledge and the
    application of the model within anorganization.
</p>
<p>
    Model Driven Systems Development (MDSD) supports the CMMI-DEV process model which&nbsp;characterizes systems
    engineering and systems engineers as follows:
</p>
<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
    <p>
        "The interdisciplinary approach governing the total technical and managerial effort required to transform a set of
        customer needs, expectations, and constraints into a product solution and to support that solution throughout the
        product's life. (See also "hardware engineering" and "software engineering.")
    </p>
    <p>
        This includes the definition of technical performance measures, the integration of engineering specialties toward
        the establishment of a product architecture, and the definition of supporting lifecycle processes that balance
        cost, performance, and schedule objectives."
    </p>
</blockquote>
<p>
    A system, which might contain hardware (computational and non-computational), software and human workers, delivers
    needed operational capability to its users, and might itself require supporting systems for successful operation.
    Systems engineering has to consider not only the specification and creation of a product, but also the in-service
    support of that product (for example, its maintenance) to ensure its continued utility.
</p>
<p>
    This view of a system extends that of the core RUP, where "<i>system"</i> is used to mean software and the
    computational hardware on which it runs. Additionally, it is likely the case that most applications of&nbsp;MDSD will
    be to large developments, where the subsystems into which the system is decomposed are themselves complex enough to be
    regarded as systems, with the implication that RUP (or MDSD) could be reapplied, in total, to their development.
</p>
<p>
    A systems engineering process has, then, to be able to deal with systems that are arbitrarily complex and large, and
    which require a multidisciplinary approach in their construction, deployment and support. The whitepaper, the <a class="elementLinkWithUserText" href="./../../../systems.mdsd/guidances/whitepapers/rational_unified_process_for_systems_engineering_536672F5.html" guid="3.3014337793664417E-305">Rational Unified Process&reg; for Systems Engineering</a> describes the motivation for the
    development of "RUP for Systems Engineering" (RUP SE).&nbsp; MDSD is an evolution of RUP SE extending the process model
    to address the problems of size and complexity (in the user needs and requirements as well as design), quality of
    service, and other engineering specialties that are&nbsp;faced by the Systems Engineer.
</p>
<p>
    The&nbsp;MDSD plug-in is also of interest to the managers of a systems development&nbsp;project, as well as those
    concerned with system analysis and specification, system architecture, implementation and test.
</p><br /></td>
</tr>
</table>
</div>
<table class="copyright" border="0" cellspacing="0" cellpadding="0">
<tr>
<td class="copyright"></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
				contentPage.onload();
			</script>
</html>
