<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Guideline: Design Subsystem</title>
<meta name="uma.type" content="Guideline">
<meta name="uma.name" content="design_subsystem">
<meta name="uma.presentationName" content="Design Subsystem">
<meta name="element_type" content="other">
<meta name="filetype" content="description">
<meta name="role" content="none">
<link rel="StyleSheet" href="./../../../css/default.css" type="text/css">
<script src="./../../../scripts/ContentPageResource.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSubSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageToolbar.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/contentPage.js" type="text/javascript" language="JavaScript"></script><script type="text/javascript" language="JavaScript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="_Mmdc0FIREd6lNtylJFsPIg"></div>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="pageTitle" nowrap="true">Guideline: Design Subsystem</td><td width="100%">
<div align="right" id="contentPageToolbar"></div>
</td><td width="100%" class="expandCollapseLink" align="right"><a name="mainIndex" href="./../../../index.htm"></a><script language="JavaScript" type="text/javascript" src="./../../../scripts/treebrowser.js"></script></td>
</tr>
</table>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td class="pageTitleSeparator"><img src="./../../../images/shim.gif" alt="" title="" height="1"></td>
</tr>
</table>
<div class="overview">
<table width="97%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="50"><img src="./../../../images/guidance.gif" alt="" title=""></td><td>
<table class="overviewTable" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top">This guideline explains how to identify and specify Design Subsystems.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relationships</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<th class="sectionTableHeading" scope="row">Related Elements</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/design_subsystem_47086B8E.html" guid="_5inEwEo2Ed6D_7XK49c0nw">Design Subsystem</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Main Description</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<td class="sectionTableSingleCell"><h3>
    <font size="4"><strong>Identifying Subsystems</strong></font>
</h3>
<p>
    A complex analysis class is mapped to a <a class="elementLinkWithUserText" href="./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/design_subsystem_47086B8E.html" guid="_5inEwEo2Ed6D_7XK49c0nw">design subsystem</a> if it&nbsp;seems to embody behavior that cannot be the
    responsibility of a single design class acting alone. A complex design class might also become a subsystem, if it is
    likely to be implemented as a set of collaborating classes.
</p>
<p>
    Subsystems also are&nbsp;a good means of identifying parts of the system that are to be developed independently by a
    separate team. If the collaborating design elements can be completely contained within a package along with their
    collaborations, a subsystem can provide a stronger form of encapsulation than that provided by a simple package. The
    contents and collaborations within a subsystem are completely isolated behind one or more interfaces, so that the
    client of the subsystem is only dependent upon the interface. The designer of the subsystem is then completely isolated
    from external dependencies.&nbsp; The designer (or design team) is required to specify how the interface is realized,
    but they are completely free to change the internal subsystem design without affecting external dependencies. In large
    systems with largely independent teams, this degree of de-coupling combined with the architectural enforcement provided
    by formal interfaces is a strong argument for the choice of subsystems over simple packages.
</p>
<p>
    The design subsystem is used to encapsulate these collaborations in such a way that clients of the subsystem can be
    completely unaware of the internal design of the subsystem, even as they use the services provided by the subsystem. If
    the participating classes/subsystems in a collaboration interact only with each other to produce a well-defined set of
    results, the collaboration and its collaborating design elements&nbsp;need to&nbsp;be encapsulated within a subsystem.
</p>
<p>
    This rule can be applied to subsets of collaborations as well. Anywhere part or all of a collaboration can be
    encapsulated and simplified, doing so will make the design easier to understand.
</p>
<p dir="ltr" style="MARGIN-RIGHT: 0px">
    The following table provides hints to use to identify subsystems.
</p><br />
<br />
<table title="" cellspacing="0" cellpadding="2" width="85%" border="1">
    <tbody>
        <tr>
            <th id="" scope="col" abbr="">
                <p dir="ltr" style="MARGIN-RIGHT: 0px">
                    Hint
                </p>
            </th>
            <th id="" scope="col" abbr="">
                <p dir="ltr" style="MARGIN-RIGHT: 0px">
                    Details
                </p>
            </th>
        </tr>
        <tr>
            <td>
                <strong>Look for optionality</strong>
            </td>
            <td>
                If a particular collaboration (or sub-collaboration) represents optional behavior, enclose it in a
                subsystem. Features which might be removed, upgraded, or replaced with alternatives&nbsp;need to&nbsp;be
                considered independent.
            </td>
        </tr>
        <tr>
            <td>
                <strong>Look to the user interface of the system.</strong>
            </td>
            <td>
                <ol>
                    <li>
                        If the user interface is relatively independent of the entity classes in the system (that
                        is,&nbsp;the two can and will change independently), create subsystems which are horizontally
                        integrated.&nbsp;Group related user interface boundary classes together in a subsystem, and group
                        related entity classes together in another subsystem.
                    </li>
                    <li>
                        If the user interface and the entity classes it displays are tightly coupled (for example, a change
                        in one triggers a change in the other), create subsystems which are vertically integrated.&nbsp;
                        Enclose related boundary and entity classes in common subsystem.
                    </li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>
                <strong>Look to the Actors</strong>
            </td>
            <td>
                <ol>
                    <li>
                        Separate functionality used by two different actors,&nbsp;because each actor might independently
                        change their requirements on the system.
                    </li>
                    <li>
                        Create subsystems to encapsulate access to an external system or device.
                    </li>
                </ol>
            </td>
        </tr>
        <tr>
            <td>
                <strong>Look for coupling and cohesion between design elements</strong>
            </td>
            <td>
                Highly coupled or cohesive classes/subsystems collaborate to provide some set of services. Organize highly
                coupled elements into subsystems, and separate elements along lines of weak coupling. In some cases, weak
                coupling can be eliminated entirely by splitting classes into smaller classes with more cohesive
                responsibilities, or repartitioning subsystems appropriately
            </td>
        </tr>
        <tr>
            <td>
                <strong>Look at substitution</strong>
            </td>
            <td>
                If there are several levels of service specified for a particular capability (example: high, medium and low
                availability), represent each service level as a separate subsystem, each of which will realize the same
                set of interfaces. By doing so, the subsystems are substitutable for one another.
            </td>
        </tr>
        <tr>
            <td>
                <strong>Look at distribution</strong>
            </td>
            <td>
                <span                 style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE">Although
                there can be multiple instances of a particular subsystem, each executing on different nodes, in many
                architectures it is not possible for a single instance of a component to be split across nodes. In the
                cases where subsystem behavior must be split across nodes, it is recommended that you decompose the
                subsystem into smaller subsystems (each representing a single component) with more restricted
                functionality. <span                 style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes">&nbsp;</span>
                Determine the functionality that must reside upon each node and create a new subsystem to 'own' that
                functionality, distributing the responsibilities and related elements of the original subsystem
                appropriately. <span                 style="mso-fareast-font-family: Times New Roman; mso-bidi-font-family: Times New Roman; mso-ansi-language: EN-US; mso-fareast-language: EN-US; mso-bidi-language: HE; mso-spacerun: yes">&nbsp;</span>
                The new subsystems are internal to the original subsystem.</span>
            </td>
        </tr>
    </tbody>
</table><br />
<br />
<h3>
    <font size="4"><strong>Modeling Subsystems</strong></font>
</h3>
<p>
    Design Subsystems are modeled using UML components stereotyped as &lt;&lt;subsystem&gt;&gt;. This construct provides
    the following modeling capabilities:
</p>
<ul>
    <li>
        can group classes to define a larger granularity part of a system
    </li>
    <li>
        can separate the visible interfaces from internal implementation
    </li>
    <li>
        can have execution at run-time
    </li>
</ul>
<p>
    Some other considerations are:
</p>
<ul>
    <li>
        Each Design Subsystem must be given a name and a short description.
    </li>
    <li>
        The responsibilities of the original analysis class&nbsp;need to&nbsp;be transferred to the newly-created
        subsystem, using the description of the subsystem to document the responsibilities
    </li>
</ul>
<h3>
    Subsystems that Represent Existing Products
</h3>
<p>
    Where an existing product is one that exports interfaces,&nbsp;that is,&nbsp;operations (and perhaps receptions), but
    otherwise keeps all details of implementation hidden, then it&nbsp;can be modeled as a subsystem.&nbsp; Examples of
    products the system uses that you might be able to represent by a subsystem include:
</p>
<ul>
    <li>
        Communication software (middleware).
    </li>
    <li>
        Database access support (RDBMS mapping support).
    </li>
    <li>
        Application-specific products.
    </li>
</ul>
<p>
    Some existing products such as collections of types and data structures (for example,&nbsp;stacks, lists, and queues)
    might be better represented as packages, because they reveal more than behavior, and it is the particular contents of
    the package that are important and useful and not the package itself, which is simply a container.&nbsp;
</p>
<p>
    Common utilities, such as math libraries, could be represented as subsystems if they simply export interfaces.&nbsp;
    Whether this is necessary or makes sense depends on the designer's judgment about the nature of the thing
    modeled.&nbsp; Subsystems are object-oriented constructs (as they are modeled components): a subsystem can have
    instances (if the designer so indicates).&nbsp;
</p>
<p>
    When defining the subsystem to represent the product, also define one or more interfaces to represent the product
    interfaces.
</p>
<h3>
    Subsystem Dependency Restrictions
</h3>
<p>
    Design Subsystems (modeled as UML components with &lt;&lt;subsystem&gt;&gt; stereotype) differ from packages in their
    semantics.&nbsp; A subsystem provides behavior through one or more interfaces which it realizes. Packages provide no
    behavior; they are simply containers of things which provide behavior.
</p>
<p>
    The reason for using a subsystem instead of a package is that subsystems encapsulate their contents, providing behavior
    only through their interfaces. The benefit of this is that, unlike a package, the contents and internal behaviors of a
    subsystem can be changed with complete freedom so long as the subsystem's interfaces remain constant. Subsystems also
    provide a 'replaceable" design element.&nbsp; Any two &lt;&lt;realization&gt;&gt; components that realize the same
    interfaces (or &lt;&lt;specification&gt;&gt; component) are interchangeable.
</p>
<p>
    In order to ensure that subsystems are replaceable elements in the model, a few rules need to be enforced:
</p>
<ul>
    <li>
        A subsystem needs to&nbsp;minimize exposing&nbsp;its contents. Ideally, no element contained by a
        subsystem&nbsp;has 'public' visibility, and thus no element outside the subsystem depends on the existence of a
        particular element inside the subsystem. Some exceptions are as follows: 
        <ul>
            <li>
                In some technologies, the externals of a subsystem cannot be modeled as a UML interface. For example, a
                Java interface is modeled as a stereotyped class.
            </li>
            <li>
                The subsystem design might require exposing classes rather than UML interfaces. For example, a "delegate"
                or "access" class can be used to hide a complex collaboration of other classes. While an ordinary package
                could be used instead, a subsystem could be used in order to emphasize the intent to encapsulate behavior
                and hide internal details.
            </li>
        </ul>
    </li>
    <li style="LIST-STYLE-TYPE: none">
        <br />
        When a subsystem's externals are not UML interfaces, it&nbsp;often is helpful to have a diagram (for example named
        "External View") that shows the visible elements of the subsystem.
    </li>
    <li>
        A subsystem&nbsp;needs to&nbsp;define its dependencies on subsystem interfaces (and publicly visible elements of
        subsystems in the exceptional cases described above). In addition, a number of subsystems might share a set of
        interfaces or class definitions in common, in which case those subsystems 'import' the contents of the packages
        which contain the common elements. This is more common with packages in lower layers in the architecture, to ensure
        that common definitions of classes which must pass between subsystems are consistently defined.
    </li>
</ul>
<h4>
    <font size="4">Subsystem Specification and Realization</font>
</h4>
<p>
    <font size="3"><strong>Definition</strong></font>
</p>
<p>
    The <a href="http://www.uml.org/" target="_blank">UML 2.1.1 Superstructure specification</a> supports separate
    definitions of component specification and realization.&nbsp; Briefly, &lt;&lt;specification&gt;&gt; denotes:&nbsp;
</p>
<p>
    A classifier that specifies a domain of objects without defining the physical implementation of those objects. For
    example, a Component stereotyped by &lt;&lt;specification&gt;&gt; will only have provided and required interfaces, and
    is not intended to have any realizingClassifiers as part of its definition.
</p>
<p>
    And, &lt;&lt;realization&gt;&gt; denotes:
</p>
<p>
    A classifier that specifies a domain of objects and that also defines the physical implementation of those objects. For
    example, a Component stereotyped by &lt;&lt;realization&gt;&gt; will only have realizing Classifiers that implement
    behavior specified by a separate &lt;&lt;specification&gt;&gt;Component.
</p>
<p>
    The separation of specification and realization allows for two separate descriptions of the subsystem. The
    specification serves as a contract that defines everything that a client needs to know to use the subsystem. The
    realization is the detailed internal design intended to guide the implementer. If you&nbsp;need to support multiple
    realizations, create separate "realization" subsystems and draw a realization from each realization subsystem to the
    specification subsystem.
</p>
<p>
    <font size="3"><strong>When and how to use</strong></font>
</p>
<p>
    If the internal state and behavior of the subsystem&nbsp;are relatively simple, it&nbsp;can be sufficient to specify
    the subsystem by its exposed interfaces, state diagrams to describe the behavior, and descriptive text.
</p>
<p>
    For more complex internal state and behavior, analysis classes can be used to specify the subsystem at a high level of
    abstraction. For large systems of systems, the specification of a subsystem might also include use cases.
</p>
<p>
    Providing a detailed specification separate from the realization tends to be most useful in the following situations:
</p>
<ul>
    <li>
        The subsystem realization's internal state or behavior is complex, and the specification needs to be expressed as
        simply as possible in order for clients to use it effectively;
    </li>
    <li>
        The subsystem is a reusable "assembly component" intended for assembly into a number of systems;
    </li>
    <li>
        The subsystem's internals are expected to be developed by a separate organization;
    </li>
    <li>
        Multiple implementations of the subsystem need to be created;
    </li>
    <li>
        The subsystem is expected to be replaced with another version that has significant internal changes without changes
        to the externally visible behavior.
    </li>
</ul>
<p>
    Maintaining a separate specification takes effort, however, as one must ensure that the realization of the subsystem is
    compliant with the specification. The criteria for when and if to create separate specification and realization classes
    and collaborations&nbsp;needs to&nbsp;be clearly defined.
</p>
<h4>
    Dependencies
</h4>
<p>
    A specification&nbsp;needs to&nbsp;define its dependencies. These are the interfaces and visible elements from other
    subsystems and packages that must be available in all compliant realizations of the subsystem.
</p>
<p>
    A realization might have additional dependencies, introduced by the designer or implementer. For example, there might
    be an opportunity to use a utility component to simplify the implementation, but the use of this utility component is a
    detail that need not be exposed to clients. These additional dependencies&nbsp;can be captured on a separate diagram as
    part of the realization.
</p>
<h4>
    Relationship to Implementation
</h4>
<p>
    A fully detailed specification defines everything a client needs to use the subsystem. This means refining the exposed
    interfaces and any publicly visible elements so that they are one-to-one with code. Leave&nbsp;any analysis classes
    that were introduced to specify the subsystem behavior&nbsp;as high level abstractions,&nbsp;because they are intended
    to be independent of any subsystem's realizations.
</p></td>
</tr>
</table>
</div>
<div class="sectionHeading">More Information</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<th class="sectionTableHeading" scope="row">Concepts</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.tech.common.extend_supp_soa-ibm/guidances/concepts/design_subsystem_47086B8E.html" guid="_5inEwEo2Ed6D_7XK49c0nw">Design Subsystem</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<table class="copyright" border="0" cellspacing="0" cellpadding="0">
<tr>
<td class="copyright"><p>
    Licensed Materials - Property of IBM<br />
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2011.&nbsp; All Rights Reserved.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
				contentPage.onload();
			</script>
</html>
