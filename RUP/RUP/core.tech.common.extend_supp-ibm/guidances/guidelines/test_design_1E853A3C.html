<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Guideline: Test Design</title>
<meta name="uma.type" content="Guideline">
<meta name="uma.name" content="test_design">
<meta name="uma.presentationName" content="Test Design">
<meta name="element_type" content="other">
<meta name="filetype" content="description">
<meta name="role" content="none">
<link rel="StyleSheet" href="./../../../css/default.css" type="text/css">
<script src="./../../../scripts/ContentPageResource.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageSubSection.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/ContentPageToolbar.js" type="text/javascript" language="JavaScript"></script><script src="./../../../scripts/contentPage.js" type="text/javascript" language="JavaScript"></script><script type="text/javascript" language="JavaScript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=null;
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="_LwxoYHHUEdyzS55ez-koKA"></div>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr>
<td class="pageTitle" nowrap="true">Guideline: Test Design</td><td width="100%">
<div align="right" id="contentPageToolbar"></div>
</td><td width="100%" class="expandCollapseLink" align="right"><a name="mainIndex" href="./../../../index.htm"></a><script language="JavaScript" type="text/javascript" src="./../../../scripts/treebrowser.js"></script></td>
</tr>
</table>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
<td class="pageTitleSeparator"><img src="./../../../images/shim.gif" alt="" title="" height="1"></td>
</tr>
</table>
<div class="overview">
<table width="97%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="50"><img src="./../../../images/guidance.gif" alt="" title=""></td><td>
<table class="overviewTable" border="0" cellspacing="0" cellpadding="0">
<tr>
<td valign="top">This guideline explains how to identify and design tests.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relationships</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<th class="sectionTableHeading" scope="row">Related Elements</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.tech.common.extend_supp-ibm/workproducts/test_design_A19BF7FA.html" guid="_fm1I4HE8Edy8Ac588DXPCQ">Test Design</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Main Description</div>
<div class="sectionContent">
<table class="sectionTable" border="0" cellspacing="0" cellpadding="0">
<tr valign="top">
<td class="sectionTableSingleCell"><h3>
    <a id="Explanation" name="Explanation">Explanation</a>
</h3>
<p>
    Nothing has a greater effect on the user's satisfaction with the software than a clear view of what the user expects so
    that those expectations can be verified and validated. Test cases reflect the requirements that are to be verified.
    Verifying these requirements, however, may be done differently and by different testers. For example, executing the
    software to verify its function and performance may be done by a tester using automated test techniques, the shut-down
    sequence of a computer system may be done by manual test and observation, while market share and sales, (also product
    requirements), will be done by measuring product and competitive sales.
</p>
<p>
    Since you may not be able to (or be responsible to) verify all requirements, it is critical for the success of your
    project to select the most appropriate or critical ones requirements for test. The requirements you choose to verify
    will be a balance between the cost, risk, and necessity of having the requirement verified.
</p>
<p>
    Identifying the test cases is important for several reasons.
</p>
<ul>
    <li>
        Test cases form the foundation on which to design and develop Test Scripts.
    </li>
    <li>
        The "depth" of the testing is proportional to the number of test cases. Greater confidence in the quality of the
        product and test process is gained when the number of test cases increases, since each test case reflects a
        different scenario, condition, or flow through the product.
    </li>
    <li>
        A principal measure of the completeness of test is requirements-based coverage, based on the of the number test
        cases identified, implemented, and / or executed. A statement such as "95 percent of our critical test cases have
        been executed and verified" is more significant than stating "We're 95 percent of the way through our tests."
    </li>
    <li>
        The scale of the test effort is proportional to the number of test cases. With a comprehensive breakdown of test
        cases, the timing of succeeding stages of the test cycle can be more accurately estimated.
    </li>
    <li>
        The kinds of test design and development, and the resources needed are largely governed by the test cases.
    </li>
</ul>
<p>
    Test cases are often categorized or classified by the type of test or requirement for test they are associated with,
    and will vary accordingly. The practice is to develop at least two test cases for each requirement for test:
</p>
<ul>
    <li>
        A test case which will demonstrate the requirement has been achieved. This is called a positive test case.
    </li>
    <li>
        Another test case, reflecting an unacceptable, abnormal, or unexpected condition or data, to demonstrate that the
        requirement is only achieved under the desired condition, referred to as a negative test cases.
    </li>
</ul>
<h3>
    <a id="DerivingTestCasesforUnitTest" name="DerivingTestCasesforUnitTest">Deriving Test Cases for Unit Test</a>
</h3>
<p>
    Unit testing requires testing both the unit's internal structure and its behavioral characteristics. Testing the
    internal structure requires a&nbsp; knowledge of how the unit is implemented, and tests based upon this knowledge are
    known as white-box tests. Testing a unit's behavioral characteristics focuses on the external observable behaviors of
    the unit without knowledge or regard its implementation. Tests based upon this approach are referred to as black-box
    tests. Deriving test cases based upon both approaches are described below.
</p>
<h4>
    <a id="WhiteBox_tests" name="WhiteBox_tests">White-Box Tests</a>
</h4>
<p>
    Theoretically, you should test every possible path through the code. Achieving such a goal, in all but very simple
    units, is either impractical or almost impossible. At the very least you should exercise every <b>decision-to-decision
    path</b> (DD-path) at least once, resulting in executing all statements at least once. A decision is typically an
    if-statement, and a DD-path is a path between two decisions.
</p>
<p>
    To get this level of test coverage, it is recommended that you choose test data so that every decision is evaluated in
    every possible way. Toward that end, the test cases should make sure that:
</p>
<ul>
    <li>
        Every Boolean expression is evaluated to <b>true</b> and <b>false</b>. For example the expression (a&lt;3) OR
        (b&gt;4) evaluates to four combinations of <b>true</b>/<b>false</b>
    </li>
    <li>
        Every infinite loop is exercised at least zero times, once, and more than once.
    </li>
</ul>
<p>
    Use code-coverage tools to identify the code not exercised by your white box testing. Reliability testing should be
    done simultaneously with your white-box testing.
</p>
<p class="exampleheading">
    Example:
</p>
<p class="example">
    Assume that you perform a structure test on a function <b>member</b> in the class <b>Set of Integers.</b> The test -
    with the help of a binary search - checks whether the set contains a given integer.
</p>
<p class="picturecenter" align="center">
    <img height="200" alt="Diagram described in caption." src="./../../../core.tech.common.extend_supp-ibm/guidances/guidelines/./resources/untst001.gif" width="301" />
</p>
<p class="picturetext">
    The member function and its corresponding flowchart. Dotted arrows illustrate how you can use two test cases to execute
    all the statements at least once.
</p>
<p>
    Theoretically, for an operation to be thoroughly tested, the test case should traverse all the combinations of routes
    in the code. In <b>member</b>, there are three alternative routes inside the <b>while-loop</b>. The test case can
    traverse the loop either several times or not at all. If the test case does not traverse the loop at all, you will find
    only one route through the code. If it traverses the loop once, you will find three routes. If it traverses twice, you
    will find six routes, and so forth. Thus, the total number of routes will be 1+3+6+12+24+48+..., which in practice, is
    an unmanageable number of route combinations. That is why you must choose a subset of all these routes. In this
    example, you can use two test cases to execute all the statements. In one test case, you might choose <code><b>Set of
    Integers</b> = {1,5,7,8,11}</code> and <code><b>t</b> = 3</code> as test data. In the other test case, you might choose
    <code><b>Set of Integers</b> = {1,5,7,8,11}</code> and <code><b>t</b> = 8</code>.
</p>
<h4>
    <a id="BlackBox_Tests" name="BlackBox_Tests">Black-Box Tests</a>
</h4>
<p>
    The purpose of a black-box test is to verify the unit's specified behavior without looking at <b>how</b> the unit
    implements that behavior. Black-box tests focus and rely upon the unit's input and output.
</p>
<p>
    <b>Equivalence partitioning</b> is a technique for reducing the required number of tests. For every operation, you
    should identify the equivalence classes of the arguments and the object states. An <b>equivalence class</b> is a set of
    values for which an object is supposed to behave similarly. For example, a <b>Set</b> has three equivalence classes:
    <b>empty</b>, <b>some element,</b> and <b>full</b>.
</p>
<p>
    Use code-coverage tools to identify the code not exercised by your white box testing. Reliability testing should be
    done simultaneously with your black-box testing.
</p>
<p>
    The next two subsections describe how to identify test cases by selecting test data for specific arguments.
</p>
<h5>
    Test Cases based upon Input Arguments
</h5>
<p>
    An <b>input argument</b> is an argument used by an operation. You should create test cases by using input arguments for
    each operation, for each of the following input conditions:&nbsp;
</p>
<ul>
    <li>
        Normal values from each equivalence class.
    </li>
    <li>
        Values on the boundary of each equivalence class.
    </li>
    <li>
        Values outside the equivalence classes.
    </li>
    <li>
        Illegal values.
    </li>
</ul>
<p>
    Remember to treat the object state as an input argument. If, for example, you test an operation <b>add</b> on an object
    <b>Set</b>, you must test <b>add</b> with values from all of <b>Set</b>'s equivalence classes, that is, with a full
    <b>Set</b>, with some element in <b>Set,</b> and with an empty <b>Set</b>.
</p>
<h5>
    Test Cases based upon Output Arguments
</h5>
<p>
    An <b>output argument</b> is an argument that an operation changes. An argument can be both an input and an output
    argument. Select input so that you get <b>output</b> according to each of the following.
</p>
<ul>
    <li>
        Normal values from each equivalence class.
    </li>
    <li>
        Values on the boundary for each equivalence class.
    </li>
    <li>
        Values outside the equivalence classes.
    </li>
    <li>
        Illegal values.
    </li>
</ul>
<p>
    Remember to treat the object state as an output argument. If for example, you test an operation <b>remove</b> on a
    <b>List</b>, you must choose input values so that <b>List</b> is full, has some element, and is empty after the
    operation is performed (test with values from all its equivalence classes).
</p>
<p>
    If the object is state-controlled (reacts differently depending on the object's state), you should use a state matrix
    such as the one in the following figure.
</p>
<p class="picturecenter" align="center">
    <img height="166" alt="Diagram described in caption." src="./../../../core.tech.common.extend_supp-ibm/guidances/guidelines/./resources/untst002.gif" width="184" />
</p>
<p class="picturetext">
    A state matrix for testing. You can test all combinations of state and stimuli on the basis of this matrix.
</p><br />
<br /></td>
</tr>
</table>
</div>
<table class="copyright" border="0" cellspacing="0" cellpadding="0">
<tr>
<td class="copyright"><p>
    Licensed Materials - Property of IBM<br />
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2011.&nbsp; All Rights Reserved.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script type="text/javascript" language="JavaScript">
				contentPage.onload();
			</script>
</html>
